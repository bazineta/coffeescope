// Generated by CoffeeScript 2.0.1
(function() {
  "use strict";
  var Scope,
    hasProp = {}.hasOwnProperty;

  module.exports = Scope = class Scope {
    constructor(parent1, options = {}) {
      var key, value;
      this.local = this.local.bind(this);
      this.identifierRead = this.identifierRead.bind(this);
      this.identifierWritten = this.identifierWritten.bind(this);
      this.getScopeOf = this.getScopeOf.bind(this);
      this.commit = this.commit.bind(this);
      this.appendErrors = this.appendErrors.bind(this);
      this.parent = parent1;
      this.symbols = Object.create(null);
      this.options = {};
      for (key in options) {
        if (!hasProp.call(options, key)) continue;
        value = options[key];
        this.options[key] = value;
      }
    }

    local(name, type = null) {
      if (!this.symbols[name]) {
        this.symbols[name] = {
          reads: [],
          writes: [],
          innerReads: [],
          innerWrites: [],
          type
        };
      }
      return this.symbols[name];
    }

    identifierRead(name, node) {
      this.local(name).reads.push(node);
      return void 0;
    }

    identifierWritten(name, node, type) {
      var ref;
      ref = this.local(name);
      ref.writes.push(node);
      if (ref.type == null) {
        ref.type = type;
      }
      return void 0;
    }

    getScopeOf(name) {
      // only safe to call after this node has been committed
      if ((this.symbols[name] != null) && this.symbols[name].writes.length !== 0) {
        return this;
      } else {
        return this.parent.getScopeOf(name);
      }
    }

    commit() {
      var innerReads, innerWrites, name, reads, ref1, scope, type, writes;
      ref1 = this.symbols;
      for (name in ref1) {
        ({reads, writes, type} = ref1[name]);
        if (type === "Argument") {
          // variable is explicitly marked as local; keep it here
          continue;
        }
        scope = this.parent.getScopeOf(name);
        if (scope == null) {
          // no matching variable found in parent scope(s)
          continue;
        }
        ({type, innerReads, innerWrites} = scope.symbols[name]);
        if (type === "Builtin" && writes.length) {
          // coffeescript treats builtins as undefined variables because
          // it doesn't know about `globals` and `environments`; reading
          // one is fine, but writing to one will create a local variable
          continue;
        }
        // if all the above rules fail, then this variable doesn't belong in
        // the current scope so we merge its usage into its parent
        Array.prototype.push.apply(innerReads, reads);
        Array.prototype.push.apply(innerWrites, writes);
        delete this.symbols[name];
      }
      return void 0;
    }

    appendErrors(errors) {
      var checkUsedBeforeDefined, comprehension, defined, innerReads, innerWrites, name, reads, ref1, type, writes;
      ref1 = this.symbols;
      for (name in ref1) {
        ({reads, writes, type, innerReads, innerWrites} = ref1[name]);
        if (!writes.length) {
          if (this.options["undefined"]) {
            (function() {
              var i, len, locationData, results;
              results = [];
              // issue an undefined variable error for every attempt to
              // read it in the current scope; since this variable was
              // never written in this scope, @getScopeOf will skip it so
              // there's no need to look in inner scopes as they will have
              // their own copy local copy
              for (i = 0, len = reads.length; i < len; i++) {
                ({locationData} = reads[i]);
                results.push(errors.push({
                  lineNumber: locationData.first_line + 1,
                  message: `Undefined identifier "${name}"`
                }));
              }
              return results;
            })();
          }
          // this is an undefined variable so all the other rules are
          // irelevant
          continue;
        }
        defined = writes[0].locationData;
        comprehension = this.symbols[name].type === "Comprehension variable";
        checkUsedBeforeDefined = function(nodes) {
          var i, isBefore, len, locationData, results;
          // issue a used-before-undefined variable error for ever
          // attempt to read the current variable before it was defined
          isBefore = function(a, b) {
            return a.first_line < b.first_line || (a.first_line === b.first_line && a.first_column <= b.first_column);
          };
          results = [];
          for (i = 0, len = nodes.length; i < len; i++) {
            ({locationData} = nodes[i]);
            if (comprehension || !isBefore(locationData, defined)) {
              // comprehensions can't be reliably checked so we ignore
              // them to avoid false positives (#16)
              continue;
            }
            results.push(errors.push({
              lineNumber: locationData.first_line + 1,
              message: `${type} "${name}" used before it was first defined (on line ${defined.first_line + 1}, column ${defined.first_column + 1})`
            }));
          }
          return results;
        };
        if (!this.options["hoist_local"]) {
          checkUsedBeforeDefined(reads);
        }
        if (!this.options["hoist_parent"]) {
          checkUsedBeforeDefined(innerReads);
        }
        if (this.options["shadow"]) {
          ((type, writes) => {
            var exception, i, len, parent, ref2;
            if (type === "Builtin") { // local builtins always shadow by design
              return;
            }
            parent = this.parent.getScopeOf(name);
            if (parent == null) { // variable is not shadowing anything
              return;
            }
            ({type, writes} = parent.symbols[name]);
            if (type === "Builtin" && !this.options["shadow_builtins"]) {
              return;
            }
            ref2 = this.options["shadow_exceptions"] || [];
            for (i = 0, len = ref2.length; i < len; i++) {
              exception = ref2[i];
              if ((new RegExp(`^${exception}$`)).test(name)) { // variable is allowed to shadow
                return;
              }
            }
            return errors.push({
              lineNumber: defined.first_line + 1,
              message: type === "Builtin" ? `Shadowing built-in identifier "${name}"` : `Shadowing ${type} "${name}" (first defined on line ${writes[0].locationData.first_line + 1})`
            });
          })(type, writes);
        }
        if (((type === "Comprehension variable" || type === "Variable") && this.options["unused_variables"]) || type === "Class" && this.options["unused_classes"] || type === "Argument" && this.options["unused_arguments"]) {
          (function() {
            var i, index, len, locationData, ref2, results;
            if (reads.length || innerReads.length) { // variable was read at least once
              return;
            }
            ref2 = writes.concat(innerWrites);
            results = [];
            for (index = i = 0, len = ref2.length; i < len; index = ++i) {
              ({locationData} = ref2[index]);
              // issue a variable-is-assigned-but-never-read warning every
              // time it is accessed (here and in all child scopes)
              results.push(errors.push({
                // context: location
                lineNumber: locationData.first_line + 1,
                message: index ? `${type} "${name}" is assigned to but never read (first defined on line ${defined.first_line + 1})` : `${type} "${name}" is assigned to but never read`
              }));
            }
            return results;
          })();
        }
        if (this.options["overwrite"]) {
          (() => {
            var checkOverwrite;
            checkOverwrite = function(nodes) {
              var i, len, locationData, results;
              results = [];
              for (i = 0, len = nodes.length; i < len; i++) {
                ({locationData} = nodes[i]);
                results.push(errors.push({
                  // context: node.locationData
                  lineNumber: locationData.first_line + 1,
                  message: `Overwriting ${type} "${name}" (first defined on line ${defined.first_line + 1})`
                }));
              }
              return results;
            };
            if (this.options["same_scope"]) {
              checkOverwrite(writes.slice(1));
            }
            return checkOverwrite(innerWrites);
          })();
        }
      }
      return void 0;
    }

  };

}).call(this);
