// Generated by CoffeeScript 2.0.1
(function() {
  "use strict";
  var BuiltinScope, Scope, ScopeLinter, defaultLinter;

  BuiltinScope = require("./BuiltinScope");

  Scope = require("./Scope");

  module.exports = ScopeLinter = class ScopeLinter {
    static default() {
      return defaultLinter; // initialized on the bottom of the file
    }

    constructor() {
      this.lint = this.lint.bind(this);
      this.newState = this.newState.bind(this);
      this.newScope = this.newScope.bind(this);
      this.visit = this.visit.bind(this);
      this.visitAssignment = this.visitAssignment.bind(this);
      this.visitAssign = this.visitAssign.bind(this);
      this.visitCall = this.visitCall.bind(this);
      this.visitClass = this.visitClass.bind(this);
      this.visitCode = this.visitCode.bind(this);
      this.visitFor = this.visitFor.bind(this);
      this.visitObj = this.visitObj.bind(this);
      this.visitOp = this.visitOp.bind(this);
      this.visitParam = this.visitParam.bind(this);
      this.visitTry = this.visitTry.bind(this);
      this.visitValue = this.visitValue.bind(this);
      this.visitExportNamedDeclaration = this.visitExportNamedDeclaration.bind(this);
      // the scope available in the current node; a new scope is pushed every
      // time a Code node is encountered and popped every time a Code node has
      // been completely visited.
      this.scope = null;
      // a list of functions that should be called in a separate sub-scope as
      // soon as the current scope is completely visited;
      // initialized, called and cleared by `newScope`
      this.subscopes = null;
      // whether a Value node is expected to read an existing value, or create
      // a new variable (either by shadowing or overwriting)
      this.reading = true;
      // a list of variable definitions to insert in the current scope;
      // created whenever a (possibly destructured) assignment is encountered
      // the list of definitions is popped and merged into the current scope
      // every time an Assign node has been completely visited.
      this.definitions = null;
      void 0;
    }

    lint(root, options) {
      var builtin, global;
      this.options = options;
      this.errors = [];
      try {
        builtin = new BuiltinScope(this.options["environments"], this.options["globals"]);
        global = new Scope(builtin, this.options);
        this.newScope(global, () => {
          return this.visit(root);
        });
        this.errors.sort(function(a, b) {
          return a.lineNumber - b.lineNumber;
        });
        return this.errors;
      } finally {
        delete this.options;
        delete this.errors;
      }
    }

    newState(reading, definitions, cb) {
      var old;
      // invokes `cb()` in a new state defined by `reading` and `definitions`
      // and restores the previous state when cb exists
      old = [this.reading, this.definitions];
      [this.reading, this.definitions] = [reading, definitions];
      try {
        cb();
        return void 0;
      } finally {
        [this.reading, this.definitions] = old;
      }
    }

    newScope(scope, cb) {
      var fn, i, len, old, ref;
      // invokes `cb` in `scope`
      old = [this.scope, this.subscopes];
      this.scope = scope;
      this.subscopes = [];
      try {
        cb();
        this.scope.commit();
        ref = this.subscopes;
        for (i = 0, len = ref.length; i < len; i++) {
          fn = ref[i];
          this.newScope(new Scope(this.scope, this.options), fn);
        }
        this.scope.appendErrors(this.errors);
        return void 0;
      } finally {
        [this.scope, this.subscopes] = old;
      }
    }

    visit(node) {
      var handler;
      handler = this[`visit${node.constructor.name}`];
      if (handler != null) {
        // assume the handler will visit its children
        handler(node);
      } else {
        // walk through all child nodes
        node.eachChild(this.visit);
      }
      return void 0;
    }

    visitAssignment(destination, {source, shadow, comprehension} = {}) {
      // handles a (potentially destructured) assignment; currently called by:
      // * visitAssign
      // * visitFor
      // * visitParam
      // * visitTry
      this.newState(false, [], () => {
        var i, len, name, node, ref, ref1, results, type;
        // create empty definition list and visit the target to populate
        if ((ref = destination.constructor.name) === "Literal" || ref === "IdentifierLiteral") {
          // work around coffeescript not producing Value nodes for all
          // types of assignments (simple ones that are part of bigger
          // statements are just stored as Literal nodes)
          this.definitions.push([destination.value, destination]);
        } else {
          this.visit(destination);
        }
        // visit source node before committing assignments
        this.reading = true;
        if (source != null) {
          this.visit(source);
        }
        // for all variables defined in this (potentially destructured)
        // assignment, find a variable matching that name in the nearest
        // scope and overwrite it, or create a new variable in the current
        // scope if no matches are found
        type = "Variable";
        if (shadow) {
          type = "Argument";
        } else if (comprehension) {
          type = "Comprehension variable";
        }
        ref1 = this.definitions;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          [name, node] = ref1[i];
          results.push(this.scope.identifierWritten(name, node, type));
        }
        return results;
      });
      return void 0;
    }

    visitAssign(node) {
      this.visitAssignment(node.variable, {
        source: node.value
      });
      return void 0;
    }

    visitCall(node) {
      var arg, i, len, ref;
      if (node.do) {
        if (node.variable.constructor.name === "Code") {
          // call that is part of a `do` statement
          // don't want to shadow in this context
          this.visitCode(node.variable, true);
        } else {
          this.visit(node.variable);
        }
        ref = node.args || [];
        for (i = 0, len = ref.length; i < len; i++) {
          arg = ref[i];
          if (arg.name != null) {
            this.scope.identifierRead(arg.name.value, arg);
          } else {
            this.visit(arg);
          }
        }
      } else {
        node.eachChild(this.visit);
      }
      return void 0;
    }

    visitClass(node) {
      // a named class produces a variable in the local scope and in this
      // regard acts like an assignment statement
      if ((node.variable != null) && node.variable.isAssignable()) {
        if (node.variable.shouldCache()) {
          // composite class definition; treat as a read for base value
          this.visit(node.variable);
        } else {
          // regular named class definition
          this.scope.identifierWritten(node.variable.base.value, node, "Class");
          if (this.definitions != null) {
            // allow named classes that are part of assignment
            // statements without requiring their names to be read
            this.scope.identifierRead(node.variable.base.value, node.variable);
          }
        }
      }
      if (node.parent != null) {
        this.visit(node.parent);
      }
      this.subscopes.push(() => {
        return this.visit(node.body);
      });
      return void 0;
    }

    visitCode(node, noShadow = false) {
      this.subscopes.push(() => {
        var i, len, param, ref;
        this.scope.identifierWritten("arguments", node, "Builtin");
        if (noShadow) {
          this.scope.options["shadow"] = false;
        }
        ref = node.params || [];
        for (i = 0, len = ref.length; i < len; i++) {
          param = ref[i];
          this.visit(param);
        }
        return this.visit(node.body);
      });
      return void 0;
    }

    visitFor(node) {
      var comprehension, i, len, prop, ref;
      // because comprehensions compile to the same AST as regular for blocks
      // we distinguish between the two by checking bounds: a comprehension's
      // body has the same location as the node itself, whereas for a regular
      // for, the body is contained within the for block
      comprehension = true;
      ref = ["first_line", "first_column", "last_line", "last_column"];
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (node.locationData[prop] !== node.body.locationData[prop]) {
          comprehension = false;
          break;
        }
      }
      if (node.name != null) {
        this.visitAssignment(node.name, {comprehension});
      }
      if (node.index != null) {
        this.visitAssignment(node.index, {comprehension});
      }
      node.eachChild(this.visit);
      return void 0;
    }

    visitObj(node) {
      var i, len, prop, ref;
      ref = node.properties;
      // object property names may be literals but are interpreted as string
      // expressions unless when part of a destructured statement
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (prop.constructor.name === "Assign") {
          if (this.reading || prop.context === "object") {
            this.visit(prop.variable);
            this.visit(prop.value);
          } else {
            this.visitAssignment(prop.variable, {
              source: prop.value
            });
          }
        } else {
          this.visit(prop);
        }
      }
      return void 0;
    }

    visitOp(node) {
      var ref;
      // unary ops ++ and -- should perform both a read and a write
      if ((ref = node.operator) === "++" || ref === "--") {
        this.visitAssignment(node.first);
        return this.visit(node.first);
      } else {
        return node.eachChild(this.visit);
      }
    }

    visitParam(node) {
      this.visitAssignment(node.name, {
        source: node.value,
        shadow: true
      });
      return void 0;
    }

    visitTry(node) {
      this.visit(node.attempt);
      if (node.errorVariable != null) {
        this.visitAssignment(node.errorVariable);
      }
      if (node.recovery != null) {
        this.visit(node.recovery);
      }
      if (node.ensure != null) {
        this.visit(node.ensure);
      }
      return void 0;
    }

    visitValue(node) {
      var name, ref;
      if ((ref = node.base.constructor.name) === "Literal" || ref === "ThisLiteral" || ref === "IdentifierLiteral") {
        // simple (single-valued) object ...
        if (node.base.isAssignable()) {
          // ... that is an identifier ...
          name = node.base.value;
          if (this.reading || node.hasProperties()) {
            // an attempt (either direct or via a property or index) was
            // made to read a variable; this may result in an undefined
            // identifier error
            this.scope.identifierRead(name, node);
          } else {
            // this results in either an overwrite or the shadowing of a
            // existing variable from an outer scope; both use def lists
            this.definitions.push([name, node]);
          }
        }
        if (node.hasProperties()) {
          // ... that may have been accesed as an array
          this.newState(true, null, () => {
            var i, len, prop, ref1, results;
            ref1 = node.properties;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
              prop = ref1[i];
              if (prop.constructor.name !== "Access") {
                results.push(this.visit(prop));
              } else {
                results.push(void 0);
              }
            }
            return results;
          });
        }
      } else if (node.base.constructor.name === "Call") {
        // handles complex assignments like foo(bar).baz = qux
        this.newState(true, null, () => {
          return node.eachChild(this.visit);
        });
      } else {
        // complex object potentially containing more values (Arr or Obj)
        node.eachChild(this.visit);
      }
      return void 0;
    }

    visitExportNamedDeclaration(node) {
      var i, len, ref, specifier;
      if (node.clause.specifiers) {
        ref = node.clause.specifiers;
        for (i = 0, len = ref.length; i < len; i++) {
          specifier = ref[i];
          this.scope.identifierRead(specifier.original.value, specifier);
        }
      }
      return void 0;
    }

  };

  defaultLinter = new ScopeLinter();

}).call(this);
